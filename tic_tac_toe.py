# -*- coding: utf-8 -*-
"""tic_tac_toe.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1afG5BEgvASRqOfPVnFyBrIfMgINeyHMq

# **Tic Tac Toe Player vs AI**
"""

"""
Tic Tac Toe Player
"""

import copy
import math
import random


X = "X"
O = "O"
D="D"
EMPTY = None


def initial_state():

    return [[EMPTY, EMPTY, EMPTY],
            [EMPTY, EMPTY, EMPTY],
            [EMPTY, EMPTY, EMPTY]]


def player(board):
    """
    Returns player who has the next turn on a board. based on even odd value
    """
    count = 0
    for i in board:
        for j in i:
            if j:
                count += 1
    if count % 2 != 0:
        return O
    return X


def actions(board):
    """
    just check if a cell is empty and can be made a move over.
    """
    res = set()
    board_len = len(board)
    for i in range(board_len):
        for j in range(board_len):
            if board[i][j] == EMPTY:
                res.add((i, j))
    return res


def result(board, action):
    """
    places curr players symbol over the board
    """
    curr_player = player(board)
    result_board = copy.deepcopy(board)
    (i, j) = action
    result_board[i][j] = curr_player
    return result_board

def winner(board):
    # Checking the rows
    for row in board:
        if row[0] == row[1] == row[2] and row[0] is not EMPTY:
            return row[0]

    # Checking the columns
    for col in range(3):
        if board[0][col] == board[1][col] == board[2][col] and board[0][col] is not EMPTY:
            return board[0][col]

    # Checking the diagonals
    if board[0][0] == board[1][1] == board[2][2] and board[0][0] is not EMPTY:
        return board[0][0]
    if board[0][2] == board[1][1] == board[2][0] and board[0][2] is not EMPTY:
        return board[0][2]

    return None

def minimax(board, alpha, beta, maximizingPlayer):
    if terminal(board):
        return utility(board), None

    if maximizingPlayer:
        value = -math.inf
        best_action = None
        for action in actions(board):
            new_value, _ = minimax(result(board, action), alpha, beta, False)
            if new_value > value:
                value = new_value
                best_action = action

            alpha = max(alpha, value)
            if beta <= alpha:
                break
        return value, best_action

    else:
        value = math.inf
        best_action = None
        for action in actions(board):
            new_value, _ = minimax(result(board, action), alpha, beta, True)
            if new_value < value:
                value = new_value
                best_action = action
            beta = min(beta, value)
            if beta <= alpha:
                break
        return value, best_action

def alpha_beta_pruning(board):
    current_player = player(board)
    maximizing = (current_player == X)
    _, action = minimax(board, -math.inf, math.inf, maximizing)
    return action

def terminal(board):
    """
    Returns True if game is over or not
    """
    if winner(board) != None:
        return True

    for i in board:
        for j in i:
            if j == EMPTY:
                return False
    return True

def utility(board):
    """
    Returns 1 if X has won the game, -1 if O has won, 0 otherwise.
    """
    winner_val = winner(board)
    if winner_val == X:
        return 1
    elif winner_val == O:
        return -1
    return 0

def print_board(board):
    for row in board:
        print(" | ".join(cell if cell is not None else " " for cell in row))
        print("-" * 9)

def main():
    board = initial_state()
    print("Welcome to Tic-Tac-Toe!")
    print("Enter moves as 'row col' (e.g., '0 0' for top-left)")

    while not terminal(board):
        current_player = player(board)
        print_board(board)

        if current_player == X:
            while True:
                try:
                    move = input(f"Player {X}'s turn (row col): ")
                    i, j = map(int, move.split())
                    if (i, j) in actions(board):
                        board = result(board, (i, j))
                        break
                    else:
                        print("Invalid move! Cell already taken or out of bounds.")
                except ValueError:
                    print("Invalid input! Please enter two numbers separated by space.")

        else:  # AI player
            print(f"Player {O}'s turn (AI thinking...)")
            action = alpha_beta_pruning(board)
            board = result(board, action)
            print(f"AI played at: {action}")

    print_board(board)
    win = winner(board)
    if win:
        print(f"Player {win} wins!")
    else:
        print("It's a draw!")

if __name__ == "__main__":
    main()